\chapter{Conclusion}

After the introduction the research ranks the quality attributes. This is done in order to find which architecture fits best with EFFE's needs. The architectures that were considered, were modular monolith, miniservices and microservices. These are the architectures that focus most on modularity. The rankings of the architectures were:
\begin{enumerate}
  \item Modular monolith
  \item Miniservices
  \item Microservices
\end{enumerate}

This was because modular monolith focusses on modularity while still being able to be developed by a small team with limited resources. This is amplified when looking at complexity and costs. This is where the modular monolith architecture excelled. Because in the end the modular monolith is compiled to one application, the complexity is way lower. A side effect of this is that it also lowers the costs. The service discovery together with a orchestrated can already ramp up the costs and modular monolith is not dependent on either one.

The best backend framework for the modular monolith is Django. This is because Django by design already implements domain driven design. A modular monolith decouples it modules by domain. So a framework that has such a functionality built in already has an advantage. The other feature of Django, that Rails, Spring, Express and Laravel did not have out of the box, was migration generation. This feature makes it easy for the developer to create migrations without human error that may be involved.

For frontend Vue was the best framework. Both Vue and React were easy to implement the modular monolith in but Vue has two way binding out of the box. In React there was a need to write these two way bindings for every different input. Angular uses dependency injection. In order to make this work smoothly with the api of the modular monolith a lot of code had to be written per module.

To build these modular monoliths a new project was created called modad. This is a modular monolith assembler and dissembler. It uses a yml file as config to create the modular monolith and load its modules on build time. The choice of to create a new project instead of implementing it in the codebase was made because modad can be used for backend and frontend. While if it was implemented in the codebase the frontend and backend assembler would look different and adds complexity.
