\chapter{Conclusion}

After the introduction the research ranks the quality attributes. This is done in order to find which architecture fits best with EFFE's needs. The architectures that were considered, were modular monolith, miniservices and microservices. These architectures have in common that their main focus is modularity. The rankings of the architectures is:
\begin{enumerate}
  \item Modular monolith
  \item Miniservices
  \item Microservices
\end{enumerate}

The modular monolith is ranked first, because focusses on modularity while still being able to be developed by a small team with limited resources. Which is amplified when looking at complexity and costs. This is where the modular monolith architecture excelled. Because in the end the modular monolith is compiled to one application, the complexity is a lot lower than the other options. Lower complexity leads to lower costs. The service discovery together with an orchestrater can already ramp up the costs and modular monolith does not dependent on either one.

The best backend framework for the modular monolith is Django. This is because Django, by design, already implements domain driven design. A modular monolith decouples it modules by domain. So a framework that has such a functionality built in already has an advantage. The other feature of Django, that Rails, Spring, Express and Laravel did not have out of the box, was migration generation. This feature makes it easy for the developer to create migrations without human error that may be involved.

For the frontend Vue was the best framework. Both Vue and React were easy to implement the modular monolith in, but Vue has two way binding out of the box. In React there was a need to write these two way bindings for every different input. Angular uses dependency injection. In order to make this work smoothly with the api of the modular monolith a great number of code had to be written per module.

To build these modular monoliths a new project was created called modad. This is a modular monolith assembler and dissembler. It uses a yml file as config to create the modular monolith and load its modules on build time. The choice to create a new project instead of implementing it in the codebase was made because modad can be used for backend and frontend. While if it was implemented in the codebase the frontend and backend assembler would look different and that adds complexity.
