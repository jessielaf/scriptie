First thing to do is install django by running:
\begin{verbatim}
    pip install Django
\end{verbatim}

Now you can start the django project with the name modular\_monolith:
\begin{verbatim}
    django-admin startproject modular_monolith
\end{verbatim}

There is now a folder is created called modular\_monolith. But before we start coding we have to add mysql as the database. First install the python mysql connector:
\begin{verbatim}
    pip install mysqlclient
\end{verbatim}

Now replace \texttt{DATABASES} variable in \texttt{modular\_monolith/settings.py} with
\begin{verbatim}
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'django',
            'USER': 'root',
            'PASSWORD': 'root'
        }
    }
\end{verbatim}

Now we can create the standard tables by running:
\begin{verbatim}
    python manage.py migrate
\end{verbatim}

Django already works with encapsulated modules but they call them apps. The next thing to do is writing the api. This can be done in the modular\_monolith section which serves as the general folder. Because Django is object oriented the api can also reflect that. In \fullref{sec:API} the specific attributes are defined thus our api would look like this:
\begin{verbatim}
    class ModuleAPI:
        def __init__(self, model, base_serializer, serializer_per_role=None):
            self.model = model
            self.base_serializer = base_serializer
            self.serializer_per_role = serializer_per_role
\end{verbatim}

Because Django already supports the idea of modules we can run two simple commands to create the shift and employee modules:
\begin{verbatim}
    python manage.py startapp shifts
    python manage.py startapp employees
\end{verbatim}

The first thing to do is creating the employee model in \texttt{employees/model.py}
\begin{verbatim}
    from django.db import models


    class Employee(models.Model):
        name = models.CharField(max_length=255)
        birth_date = models.DateField()
        email = models.EmailField()
\end{verbatim}

Before the creation of the api for employees we create the base\_serializer. For this we need a rest\_framework:
\begin{verbatim}
    pip install djangorestframework
\end{verbatim}

Now add rest\_framework to settings.py in \texttt{modular\_monolith/settings.py}
\begin{verbatim}
    INSTALLED_APPS = [
        'rest_framework',
        ...
    ]
\end{verbatim}

Create the serializer in \texttt{employees/serializers/base.py} like so:
\begin{verbatim}
    from rest_framework import serializers
    from employees.models import Employee


    class BaseSerializer(serializers.ModelSerializer):
        class Meta:
            model = Employee
            fields = '__all__'
\end{verbatim}

Next the creation of the module api for employees. We do this by creating \texttt{api.py} in \texttt{employees/api.py} with the contents:
\begin{verbatim}
    from employees.models import Employee
    from employees.serializers.base import BaseSerializer
    from modular_monolith.api import ModuleAPI

    api = ModuleAPI(Employee, BaseSerializer)
\end{verbatim}

Now the model of shift can be created:
\begin{verbatim}
    from django.db import models
    from employees.api import api


    class Shift(models.Model):
        title = models.CharField(max_length=255)
        start = models.DateField()
        end = models.DateField()
        employees = models.ManyToManyField(api.model)
\end{verbatim}

As you can see this is the first time the module api is used. The api is included and used to create a many to many relationship.

The shifts serializer is the same as the one from employees except for the model:
\begin{verbatim}
    from rest_framework import serializers
    from shifts.models import Shift


    class BaseSerializer(serializers.ModelSerializer):
        class Meta:
            model = Shift
            fields = '__all__'
\end{verbatim}

The api of shifts looks like this:
\begin{verbatim}
    from shifts.models import Shift
    from shifts.serializers.base import BaseSerializer
    from modular_monolith.api import ModuleAPI

    api = ModuleAPI(Shift, BaseSerializer)
\end{verbatim}

The django application expects that in \texttt{modular\_monolith/settings.py} the apps are added to \texttt{INSTALLED\_APPS} like such:
\begin{verbatim}
    INSTALLED_APPS = [
        ...
        'employees',
        'modular_monolith'
    ]

    
    REST_FRAMEWORK = {
        "DATE_INPUT_FORMATS": ["%d-%m-%Y"],
    }
\end{verbatim}

Now run the command makemigrations and migrate in order to create the tables for the new modules:
\begin{verbatim}
    python manage.py makemigrations
    python manage.py migrate
\end{verbatim}

Add the list serializer to the \texttt{serializers/list.py} from both modules as such:

employees/serializers/list.py
\begin{verbatim}
    from rest_framework import serializers
    from employees.models import Employee
    from shifts.api import api
    
    
    class ListSerializer(serializers.ModelSerializer):
        shifts = api.base_serializer(source='shift_set', many=True)
    
        class Meta:
            model = Employee
            fields = '__all__'
\end{verbatim}

shifts/serializers/list.py
\begin{verbatim}
    from rest_framework import serializers
    from shifts.models import Shift
    from employees.api import api
    
    
    class ListSerializer(serializers.ModelSerializer):
        employees = api.base_serializer(many=True)
    
        class Meta:
            model = Shift
            fields = '__all__'  
\end{verbatim}

And the create serializer for both:

employees/serializers/create.py
\begin{verbatim}
    from rest_framework import serializers
    from employees.models import Employee


    class CreateSerializer(serializers.ModelSerializer):
        class Meta:
            model = Employee
            fields = '__all__'

\end{verbatim}

shifts/serializers/create.py
\begin{verbatim}
    from rest_framework import serializers
    from shifts.models import Shift


    class CreateSerializer(serializers.ModelSerializer):
        class Meta:
            model = Shift
            fields = '__all__'

\end{verbatim}

Now add the views to \texttt{employees/views.py} and \texttt{shifts.views.py} respectively as such:

employees/views.py
\begin{verbatim}
    from rest_framework import viewsets
    from employees.models import Employee
    from employees.serializers.create import CreateSerializer
    from employees.serializers.list import ListSerializer


    class MainViewSet(viewsets.ModelViewSet):
        queryset = Employee.objects.all()
        serializer_class = ListSerializer

        def get_serializer_class(self):
            if self.action == 'create':
                return CreateSerializer

            return super().get_serializer_class()
\end{verbatim}

shifts.views.py
\begin{verbatim}
    from rest_framework import viewsets
    from shifts.models import Shift
    from shifts.serializers.create import CreateSerializer
    from shifts.serializers.list import ListSerializer


    class MainViewSet(viewsets.ModelViewSet):
        queryset = Shift.objects.all()
        serializer_class = ListSerializer

        def get_serializer_class(self):
            if self.action == 'create':
                return CreateSerializer

            return super().get_serializer_class()
\end{verbatim}

Next is the addition of the views to the main application. Thus \texttt{modular\_monolith/urls.py} looks like:
\begin{verbatim}
    from rest_framework.routers import DefaultRouter
    from shifts.views import MainViewSet as Shift
    from employees.views import MainViewSet as Employee

    router = DefaultRouter()
    router.register('employees', Employee)
    router.register('shifts', Shift)

    urlpatterns = router.urls
\end{verbatim}

Now run \texttt{python manage.py runserver} and these urls are available to see the created api
\begin{itemize}
  \item localhost:8000/employees/
  \item localhost:8000/shifts/
\end{itemize}
