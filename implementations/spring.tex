Spring has something called initliazr which can be found at \hyperref{https://start.spring.io/}. On this site select Kotlin as the language, leave group empty, fill artifact with modular\_monilith and last of all add JPA and MySQL as a dependency.

First the interface for the API in \texttt{src/main/kotlin/modular\_monolith/Api.kt}:
\begin{verbatim}
  package modular_monolith

  import kotlin.reflect.KClass

  interface Api {
      fun getSerializer(): KClass<*>;
      fun getRepository(): KClass<*>;
  }
\end{verbatim}

Spring is originally a layered architectures. Right now all the layers will be implemented in one package.

First the model is created \texttt{src/main/kotlin/modular\_monolith/employee/Employee.kt}
\begin{verbatim}
  package modular_monolith.employee

  import java.util.*
  import javax.persistence.Entity
  import javax.persistence.GeneratedValue
  import javax.persistence.Id

  @Entity
  data class Employee(@Id @GeneratedValue
                      val id: Long,
                      var name: String,
                      var birth_date: Date)
\end{verbatim}

Next the repository which handles the database actions for the employee model.

\texttt{src/main/kotlin/modular\_monolith/employee/EmployeeRepository.kt}
\begin{verbatim}
  package modular_monolith.employee

  import org.springframework.data.repository.CrudRepository
  import org.springframework.stereotype.Repository

  @Repository
  interface EmployeeRepository: CrudRepository<Employee, Long> {
  }
\end{verbatim}

Next up is the controller which handles the requests.
\texttt{src/main/kotlin/modular\_monolith/employee/EmployeeController.kt}

\begin{verbatim}
  package modular_monolith.employee

  import org.springframework.web.bind.annotation.GetMapping
  import org.springframework.web.bind.annotation.RequestMapping
  import org.springframework.web.bind.annotation.RestController

  @RestController
  @RequestMapping("/employees")
  class EmployeeController(val employeeService: EmployeeService) {
      @GetMapping()
      fun list() = employeeService.getAll()
  }
\end{verbatim}

Next up the serializer which serializes the employee object
\texttt{src/main/kotlin/modular\_monolith/employee/serializers/BaseSerializer.kt}
\begin{verbatim}
  package modular_monolith.employee.serializers

  import java.util.*

  data class BaseSerializer(val id: Long, val name: String, val email: String, val birth_date: Date) {}
\end{verbatim}

Last of all is the api in \texttt{src/main/kotlin/modular\_monolith/employee/EmployeeApi.kt}
\begin{verbatim}
  package modular_monolith.employee

  import modular_monolith.Api
  import modular_monolith.employee.serializers.BaseSerializer

  class EmployeeApi: Api(BaseSerializer::class, EmployeeRepository::class)
\end{verbatim}

Next up is the shift module. As with the employee module we begin with the model:
\begin{verbatim}
  package modular_monolith.shift

  import modular_monolith.employee.EmployeeApi
  import java.util.*
  import javax.persistence.Entity
  import javax.persistence.GeneratedValue
  import javax.persistence.Id

  @Entity
  data class Shift(@Id @GeneratedValue
                  val id: Long,
                  var start: Date,
                  var end: Date,
                  var employees: EmployeeApi().model[])
\end{verbatim}

Unfortunately this is not valid kotlin. There is no easy way for us to define a many to many relationship via this method. It is also not clear how to do this in any other way. This specific use case is not easy for spring. It takes a lot of custom code per module. Therefor spring is not the right framework for a modular monolith.
