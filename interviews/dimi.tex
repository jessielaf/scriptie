\subsection{Interview with Dimitrios}

Jessie: Hello Dimi. So right now I'm writing my thesis to finish my bachelor's degree. In software engineering and my subject has a lot to do with architecture or it is. It is architecture. So that is why I came to you and I want to ask some questions about software architecture. So the first one is big. So what do you think software architecture is.

Dimi: There are official definitions and there are so many actually that basically I'm pretty sure no one will give you the same definition. But for me software architecture is when you think of a system how it's organized the relationship between the components you know how the application is deployed. All the principles that guide know the building and the design of the application.

Jessie: So if I'm understanding it correctly it's more like an abstract layer that is just above code. So if the actual code and then you have the architecture to right above that and then make the design above that again.

Dimi: What do you mean design?

Jessie: So you have software design and software architecture. Do you have a difference in those definitions or?

Dimi: The thing is that. Well first I to comment on. You said it's a level above like abstract level. I do not consider it as a level. Well maybe if you look at it like you have to start somewhere. You cannot just start something with that right. Because you really need to have a plan. You cannot just go build something blindly. Then again then the thing is that so we're literally splitting the collection of the principles like that those guidelines. And if you compare that with buildings you know you know the architects already would create this plan that looks and plan with their civil engineers will take and then start building them like the rest. This plan is basically software architecture.

Jessie: So in Endouble. What is the main job of a software architect. Well what what is a day to day job.

Dimi: Well we do not have a dedicated role in Endouble and that's why you have me which is basically the next round of CTO and software architect because I have the background. But usually what what we do is you know you work with this. We delegate to the tech leaders. You know you take that it takes a decision which they do that together with me when we discuss it and then you know tech leads meeting. So what does an architect do usually in Endouble? The architect ensures that he balance the non-functional requirements and the company requirements at the same time. For example you have you know you have clients that have some requirements that their website needs to be performing. It has to be able to handle that amount of requests per second. It has to be robust. You know the architect still in Endouble has to make sure that their applications can satisfy those requirements. But at the same time they satisfy the company requirements which are meant to make it easier, you know, to understand all this kind of stuff.

Jessie: So they they're balancing so just to go back to the definition of ISO, ISO is given the 25010. I do not know if you're familiar with the quality attribute. Yeah. So what you're saying is that the software architect balances the requirements of the company with the quality attributes.

Dimi: Yes but with a special focus on the non-functional requirements

Jessie: Yes exactly. So what kind of architectures have you worked with?

Dimi: Of course the one known to all of us: the monolith. We have build the layer architecture which is that you know sometimes you know it has MVC. Pretty common in web applications. I have worked with service oriented architecture and I hate it. Microkernel you know?

Jessie: No I do not know microkernel.

Dimi: you know when you have a word with thinking. You really know it. I am gonna tell you later about it. Of course I work with them in micro services which I love. Event Driven Architecture. Yeah. Very very fond of that thing and space based. You also have worked with space based and pipes and filters is something I work with, with my personal projects, which i really love. And serverless but only experimenting. I do not have work experience with it.

Jessie: So space based and microkernel. Those are the two I am not familiar with.

Dimi: So microkernel is basically when you have a let's say common core and on top of that you can enhance it with other kind of modules. If you look at wordpress, it is exactly that. It has a kernel, something that you can see as the core and than you can add more.

Jessie: Ah that is what CSB is build on right?

Dimi: Exactly. But that is the thing about microkernel. And the thing in your questions you had written modular monolith. I wasn't familiar with modular monolith. But what you mean is actually the microkernel. It is a monolith that is modular and that you can extend.

Jessie: I could not find the official term.

Dimi: Microkernel is the official term.

Jessie: To bad I found out so late it is called that.

Dimi: The thing is that all that stuff like I also wasn't familiar with the official term and because we know you learn also by experience and I think the software architecture of o'reilly where I go. I am a veteran there. I know all of them. Since 2015 I go there. This is where I meet all the great architects and where I hear about it all standard, official terms. That is also where I learned space based. You know it because space based is nothing more than you know when you scale horizontally.

Jessie: So mircoservices is also space based?

Dimi: Kind of. Microservices has a different principle.

Jessie: That is quite a lot of architectures. So you of course have a lot of experience implementing these architectures. And because you have implemented so many what was the biggest pitfall that you saw with most with most of them. Yes. Did you underestimate the certain thing multiple times or what. Yeah. What was the biggest pitfall.

Dimi: I will tell you. Not only are you asking me when I implemented those but also when I saw to my team members implement them?

Jessie: Both!

Dimi: Well I think the biggest one is when you pick an architecture that satisfies in requirement that it's not there. This is pretty common from developers that I've seen when you know they want to pick an architecture because it is more performant or faster or whatever but you were never asked to make it more performant. And now when you do that you bring all the complexity of that architecture that solves the performance. That it was never there. You have to deal with all the complexities. That's that is for me the number one pitfall.

Jessie: What most of the times happen when people are implementing microservices.

Dimi: Yes but there is also a way to make microservices simple. So you do not have to go out of your way. But than again that is the thing. Well I think the next question is. How you decide.

Jessie: Exactly. So the let's first jump in. The better question would be then so yeah How would you decide what architectures best for your current application as you said. You have to. You have to take into account these these quality attributes but how do you go about your way in doing that.

Dimi: So what I would do is first of all I get together the requirements and there are two places that I can gather that first places the client. So the client will tell me what exactly they want and I have to go and ask them the important questions about the non functional requirements in terms of security, scalability, redundability, robustness. This kind of stuff and performance of course. Well these are you know what are important for their client. And at the same time I have to take into account the company requirements. And this is what some people actually forget to do. What are the company requirements. The company requirements are maintainability of course easy to understand. Easy to add code or remove but one more thing that people tend to forget is they do not take into account the capabilities of a company. So if your company does not have the experience how can you go on and take an architecture that requires that. Right now even with microservices. Even though they are very simple. And if you think of them alone as services if you think about it the infrastructure that you need to make them communicate to make them deployed in that kind of stuff. It requires a lot of devops work. And if your company cannot afford it. Either because it doesn't have the experience or because it does not have the capacity right then it's wrong to pick that architecture. This is what you have to balance. You take those two a let's say a sources of non-functional requirements and then you pick the best that balances. Thats how you go.

Jessie: Yes that sounds good. So which architecturally do you prefer implementing and probably. Again it is requirements specific. So I will give an example of what I'm implementing and maybe you can give you a rationale or what you would implement of course you do not have the full picture but yeah. So right now I am building an application, EFFE, it is planning software for employment agencies. You have a main application, so you have a main application which has basic functionalities. But there is a possibility that big client comes in. He says Okay I want these basic functionalities changed. I want that a user has an extra field, when I save user should be called to my to another system et cetera et cetera. There's a lot of requirements. It should be very modular much I mean maybe the is not the best word. Flexible. Flexible it should be very flexible in order to have the basic function of basic application but also the application that is more catered to a certain client that will pay more. And then the question is how would you. Which architecture do you think it's best for backend and frontend.

Dimi: So basically what's you said right now it's a pretty typical application. But you didn't mention any of the non-functional requirements. Which are the ones that dictate. But anyway I can already understand from your case because you are the sole developer. So immediately having unpacked some equipment there you need to be able to have enough time to maintain that so it doesn't think you for life. So you can do other stuff you can enjoy your life.

Jessie: Well actually. So my the first thing I did with my thesis I was ranking quality attributes and what I found most important and I can give you here the quick recap the first one is maintain ability. The second one is compatibility. Third one is functional. Sustainability security reliability performance portability usability because yeah performance is not really important for us/

Dimi: Social performance is subjective like. You would notice that in web applications performance doesn't really matter much. It would not matter and I do not know maybe the voting applications where you really have.

Jessie: Yeah okay. So in your opinion what do you think. Yeah. Talk to just tell me what what you take in and how are you...

Dimi: Will tell you how I would approach it. For more of those architectures. There's always something that I am leaning towards and I can already tell you that of course for me microservices is the way to go. I'm fairly convinced about that and actually love the whole idea. But they will not pick it for the simple project or a small project, right. Because of the overhead that it requires in terms of your devops and a lot of other stuff that I have to put myself in. I learned how to do it. Yeah. So I can do it and I'm doing it for my project but it's a pain in the ass. And then what I would do is try to make scaled down versions of that for example if you think about the whole microservices that you keep a one set of service independent of each other right. You can even structure that in one you know even in the monolith or you know in your backend as different packages and those packages have their own migrations, their own configuration, their own classes and everything there and you know for connections, drivers and they can potentially be taken apart and be deployed independently in another you know service but it's fine if they live, at the start of the project, there. And they can maintain it easier. I can test it also easier because the important part is that by the time you want to switch to microservices you're testing should already be in place and the testing difficulty increases as well. Because of this decoupling that is there. However when it is on the same application the existing tools that we have are pretty good. So if you take advantage of the principles of microservices but say in one application for starters for me it is always the way to go. But I have also some rules like if it's a website that you need to build it MVC I will pick that because it's a proven way. There is no need to go microservices for a website.

Jessie: Okay. Yeah. That's so so what you recommend is then micro kernel or/

Dimi: I would not go for a micro kernel at the start. Making sure it is a separate library or package or whatever you call it, is independent and decoupled from the rest. And this a micro kernel gives me at all times at times the possibility to take it that way and have it as a depedently deployable microservice. So I get best of both worlds.

Jessie: Yeah and you get you get to decoupling and the encapsulation of microservices.

Dimi: Yeah. So if there is a new requirement that comes in for let's say performance or something then you can scale up. But why you do it from the start. You know pay all of the cost.

Jessie: Exactly. OK. So yeah that was my. There was. These were the questions a bit more about server architecture. Next few questions will be about modularity. Yeah. So yeah. The first thing what comes up to you when I say modular architecture

Dimi: When I hear modular the first thing is decoupled components. With anything that might include to either independently deployable or not. Then the whole idea of building modular that is not its decoupled and you can replace it.

Jessie: I think we already touched upon this a lot but your opinion the most what are the most. What are upcoming architectures that are focused on modularity.

Dimi: I can tell you already microservices is the king. Yeah it's proven now. You would see a lot of buzz last year on the conference. Yeah but now it's pretty standard. There is no better thing for him than microservices because microservices give you not only the ability to have components you can replace. With anything else at all times it gives you the ability to have your own whatever language you want, whatever datastore. Whatever services. It does not matter. So the king is microservices. But then if you ask me about upcoming architectures then you should already know about the evolutionary architecture right.

Jessie: No I haven't heard of.

Dimi: Yes evolutionary is a term I first heard two years ago at the software architecture conference by neal ford. Very great guy and everything and he's been doing talks on that since then and the whole idea of evolutionary architectures is that you build an architecture that really aligns with the days agile and everything. The main problem sentiment was that when you built an architecture. Systems evolve, systems change. You can never beforehand think you're the best structure for what is gonna come. You do not know. So what do you do is you make enough architecture that can support your and a little bit towards the future needs and then you build on top of that. But how do you sure of that you know your architecture are yeah really adheres or satisfies the requirements you set. This is where the evolutionary theory defines their fitness functions. The fitness functions are basically something like test automated test. That you do against the non-functional requirements so you say for example I want my architecture to be able to support 50 users per minute. Or per second or whatever. Right. Yeah. So you make this a fitness function. It's something that you can run in automated means that can show you that that system works like that. Then you can evolve the architecture and can switch from microkernel into microservices. You can always run that function. I change the architecture but it still adheres to the non-functional requirements. So yes I can evolve it without it losing the most important piece that I know.

Jessie: OK. So it's about it's more about making tests for the non-functional requirements?

Dimi: Yes it's it's actually not only making tests.

Jessie: Well you want to you want to make sure that you're non-functional requirements that you set beforehand will be adhered to even though you change architecture.

Dimi: Yes and this will allow you to change the architecture and experiment with other type of architectures while making sure that you keep those. The problem is that sometimes you cannot test all of the non-functional requirements. Performance is super easy to test.

Jessie: Usability is very hard.

Dimi: Yeah try testing maintainability. Maybe you can think of I dunno measure the time say one like. You have some metrics from quality systems say. Some are good but still it's super hard to test and you do not know if it's very representative. But it's a good way to go and read more about that because I think this is the future. Because you have styles. But then again like you said you pick the one that fits what is best for a problem but the problem changes become greater or smaller. Other stuff so you have to change the architecture and that's a good way to make sure that you always adhere and can evolve.

Jessie: Okay so this is we we're not talking about architectures. And of course architecture just when implementing there is a need to choose like a framework and most of the time you choose a framework and language. Which language. Well let's start with the language. Which language went language do you think complements modularity most.

Dimi: I saw your question beforehand. I would not recommend any specific language. I would tell you this though I would go with a language that has enough support for modules and modularity. I will give you an example right because with microservices you can pick any language that you want doesn't mean that he can pick brain fuck right. But you can if you would like it. Because its a restful api for your service and it hides all of them you know what the Internet and what happens you can use it. Right. The thing is though that you will notice that some languages have better support for modules and packages than others. Let go look at the. You know for example javascript although it's trying to do well you will see there are problems with the modules like they're not really they're not native. First of the module concept you know. They're doing it now.

Jessie: It's native in node but not in javascript.

Dimi: Sure you will see also problems that when you do imports that you actually have to refer to the actual file location. Compare that for example to PHP where do you and you do not import do you say use and it's a class a namespace in the class. Doesn't matter where it is stored on the disk. You see different type of you know support. Now you can move the class. When now all you have to change is the namespace while in javascript you need to change the actual source code in a file. And you will see problems there. Sometimes you know you can not have modules with the same name. So I would not pick a language, but I would pick when, a specific language I mean. But I would would suggest the language that has the best support.

Jessie: Because you you read I only mentioned non statically typed languages do you think static typing has something to do with how much and how good modularity is?

Dimi: Well my previous experience with statically typed languages. Hes been many years I would take Java and C++. But because I play still a bit in unity with C\#. I can tell you but I do not have that much experience in that area. I can already tell you that they have modules because I can just add another a library dynamically library to my existing program and it just works. I do not know the magic's behind it to be honest because they come in spent so much time with that but I know it's possible. Doesn't matter if statically typed. Now if the mechanism is there and you know that statically typed languages especially C++ I love it that's how you put plug ins in the game.

Jessie: I'm you know well the you look at Scala it's one of the languages it's really built for statically typed things. So this is about There programming language and I'm thinking can go to furthering to frameworks. I know you work a lot with PHP. But then again like what do you think a framework needs to complement the modular modular system or.

Dimi: Well support for packages.

Jessie: Yes but for example if there is a framework already has these these layers of modules that will be natively or native to the framework. As such. Yeah well how would you think about it. Because it you use symphony here right.

Dimi: Yeah and laravel also.

Jessie: So when do you think symphony is a better choice when do you think laravel is a better choice when do you think express a better choice etcetera etcetera.

Dimi: Well this is all subjective nowadays. Why. Because if you asked me two years ago I would tell you go with laravel. Now if you tell me between laravel and the symphony I would tell you that it is pretty much the same. Because the thing is that there are frameworks that come from different communities with their. If they're both opinionated frameworks. Yeah right. And as with all frameworks are actually opinionated apart from Microsoft which actually goes and says Hey I'm not going to allow the community to make their own framework I will set up a framework for a start and actually they are doing well with the dotnet core. They took the best practices. It's fucking awesome. I love C\# and the dotnet core it's amazing. The thing is that you know frameworks are opinionated and the things you look at the complexity. Because framework is it's nothing. It's again code that someone else wrote to make your life easier. And the goal of the framework is to make your life easier. Yeah. When you come to the point that you have to spend more time maintaining the framework you know. Instead of being writing the code to sort of the problem that you were called. Than your framework is a problem. So yeah in the past I would always recommend laravel against symphony at all times. Now if you see the symphony flex and all. It's the same thing. They basically took the whole concept of larvel. Even the way you will write the. Yeah they took the concept and it's pretty much the same right now. So if you asked me. Yeah of course it has still a bit of symphony flavor. at some parts. But then again any week now it's. And if you take a look at dotnet core. Basically you see kind laravel. Dotnet core is exactly like it was playing doing some quick start and playing around with a simple API it felt like it was running laravel.

Jessie: So it felt like very familiar?

Dimi: Yes. That's the thing that you know years have passed and people have understood that hey we need to simply by simplify some part some frameworks do it better. Those frameworks are actually worse in other parts. So they evolve. Thats the thing.

Jessie: So the last questions are about choosing the architecture and the method. So. Yeah we all do. Again we already went over this. So did I do not know if he saw the image I sent you.

Dimi: Yeah but I had some questions.

Jessie: So yeah it was what it basically was was a software architecture. Yeah it gives priority. To quality the attributes and a priority has a rationale behind it and these quality attributes or the quality attribute has potential implementations. These these potential in implementations have drawbacks and these drawbacks are again on the quality attributes. For example when we want a lot of performance or a lot of performance let's say so I'm gonna implement micro services because of the scalability but it will it has a drawback to maintain ability for example and then when the cycle completes you. You'll end up with a software architecture.

Dimi: Well to be honest when I saw that being said it was a bit confusing. I guess how you described and what is in the picture was kind of confusing. But yeah. The thing is that I kind of agree because the job of the architect is there to balance, to balance the trade tradeoffs. Yeah because there is all of the one of the approaches have problems. So as my friend Neal Ford says. Actually they closed the letter really. Yeah actually I know him. I asked him to be my mentor he had I should sent him an email. But I never did. But he recognizes me at the conferences. Anyway and the things that he said that our job is basically to trade one problem for the simpler problem. That is the job of an architect. So you make tradeoffs. Trying to get the smallest problem for you that is easy for you to solve. So of course yes. The thing is I'm not sure about the priority part because they priorities usually given by the company of the client. They decide this has priority for me. And then of course the architect will say what can I do. Given this is my priority. Yeah. Can I satisfy them. If not of course. He has some important. He can propose alternatives so he can influence the client and the company. Because that's what you will do also in the company. You will go to your stakeholders say Okay guys there are a lot of throwbacks in this approach but if we invest a little bit more will we gain the long run so we can hire some freelancers get that knowledge that we didn't have before and it better for us. Even though at the start we do not want to do it.

Jessie: Exactly. So what you're saying is maybe the software architect doesn't really give the priority to the quality he attributes but he gets the priority from the requirements.

Dimi: And than he is the one that balances it.

Jessie: I know in Endouble there was a lot of talk about domain driven design. What are your opinions about that concept?

Dimi: I love it. For me it's a must. Like if you want to be considered a software architect you really have to know domain driven design. That is for me that's super important. Yeah and the thing is that he started with domain driven design many years ago simply because the concepts. Actually you would be surprised when I tell you that. If you go and look at them and enterprise java beans from 2000. I do not exactly remember the name. It is enterprise something. You will see the exact fucking same concepts in there but people would not understand it. And of course Java made us, as it usually does, your live harder implementing some parts. A lot of fixing things.

Jessie: Yes a lot of noise.

Dimi: A lot of noise. But the concepts where there. You will see for example when you study the structures. This is exactly what domain driven design talks about. So for me I love domain driven design because with this you clearly understand where you have to put your boundaries and if the architect understands where the boundaries are. He know how to make a modular application. he knows where to put the lines. And to make sure that those lines are kept strict and make them more robust. Make sure, you know, everything is simpler. Domain driven design is really, for me when I understood the concept, it really drag me to the next level.

Jessie: So it is not even a consideration anymore? You do not make anything that is not domain driven design?

Dimi: The thing is. From my experience I will not go full 100% domain driven design. Everything that is there but I get all the good parts. Without those good parts I will not believe I would be as good as I am today.

Jessie: Okay so than the last question where we also touched upon is the modular monolith and what you call the micro kernel.

Dimi: I think what you are revering to is the microkernel because I am not familiar with the modular monolith.

Jessie: I'll explain a bit. It is really bound to domain driven design. For each domain you have a certain package or module, whatever. And this package can talk to other packages but only over an api. A predefined interface. In this way each package shows one model and a serializer for example. This can be bigger of course. Right now the first concept is only the model and serializer. So you can have foreign keys in there. And you can serialize those foreign keys in the rest api. What than happens is that on build you can switch these modules. For example you have a user module and there is a second user module and you can switch these user modules. But because they are talking over the same api there is nothing changing in the rest of the application. I also have an example if you need it.

Dimi: I understand it because this is what I was telling you. This is microkernel. So you have a core. For example in my core is the DHCP layer. I have a framework that does that part and it gives me a container, gives me the service provider structures for example. The router and that is basically it and maybe the logger, right. That is what you need as basis right. Because I can always deploy separate router and service but you do not have to. Because it is its own package that you register. Your package provider or your bundle provider in symphony whatever it is called. It does not really matter. And than you can always replace with whatever you want.
