\chapter{Implementation of the architecture}

The chosen implementation is modulair monolith. Let’s go over the characteristics of modular monolith. As mentioned in \fullref{sec:ModularMonolith} a modular monolith is a domain driven design where the modules can be developed separately. Thus most of the principles we can take from domain driven design. But because the modules do not know what other modules contain. Thus there should be a kind of api on which the modules talk.

\section{Characteristics}

Domain driven design was coined by Eric Evans in his book Domain driven design \cite{domainDrivenDesign}. Eric Evans himself said that there is no real standard for domain driven design. Let’s first define what a domain is.

\largequote{A domain is a field of study that defines a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering. The word domain is also taken as a synonym of application domain It is also seen as a sphere of knowledge \cite{domainDefinition}}

What is important to note is that each module is linked to a domain but there is a distinct difference between only implementing domain driven design and modular monolith. The main distinct feature is that in a modular monolith the module does know that another module exists but not the contents of this module. This is not the case with domain driven design.

The difference that this makes it that each module should be able to talk with each other and thus there need to be an api over which each module can talk with each other.

\section{Current situation}

This architecture will apply to the application of EFFE. Below is a list of the functionalities of the current application. This is so we can paint a good picture of the current situation.


Each functionality belongs to a certain domain. When looking at the functionalities we can determine that there are x domains which are the following:

\begin{tabularx}{\linewidth}{|>{}X|>{}X|>{}X|}
    \hline

    Domain
     &
    Functionalities
    &
    Is building block
    \\ \hline

    User
     &
    \begin{compactitem}
        \item Reset password
        \item User CRUD*
    \end{compactitem}  
    &
    No
    \\ \hline

    Shift
     &
    \begin{compactitem}
        \item Shift overview
        \item Create shift
    \end{compactitem}
    &
    No
    \\ \hline

    Skill
     &
    \begin{compactitem}
        \item Skill CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Store
     &
    \begin{compactitem}
        \item Store CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Client
     &
    \begin{compactitem}
        \item Client CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Authentication
     &
    \begin{compactitem}
        \item Login
        \item Reset password
    \end{compactitem}
    &
    No
    \\ \hline

    Schedule
     &
    \begin{compactitem}
        \item Generate schedule
    \end{compactitem}
    &
    No
    \\ \hline

    Hour registration
     &
    \begin{compactitem}
        \item Hour registration
    \end{compactitem}
    &
    Yes
    \\ \hline

    Shift market
     &
    \begin{compactitem}
        \item Shift market
    \end{compactitem}
    &
    Yes
    \\ \hline

    Shift change
     &
    \begin{compactitem}
        \item Switching shifts
        \item Calling in sick
    \end{compactitem}
    &
    No
    \\ \hline

    Company
     &
    \begin{compactitem}
        \item Managing company settings
    \end{compactitem}
    &
    No
    \\ \hline
\end{tabularx}

\small{\textcolor{gray}{* CRUD or Create Read Update Delete refers to the actions that can be called on an object}}

As you can see there are only two building blocks. Those are the Hour Registration and the Shift market. But this does not mean that the other domains should not be modules. If every domain is a module it makes it easy for us to change a basic function if an enterprise wants that.

\section{API}

Microservices talk with each other via a protocol. The most used protocols are HTTP, TCP or AMQP \cite{microservicesAPI}. What all of these protocols have in common is that they return a serialized version of the response. Most of the time in JSON.

Commonly in web frameworks there is something used like a dataclass or a serializer. This shows what of an object will be serialized into a JSON object and send back and forth via http. Thus if the api of a module in the modulair monolith can expose such a serializer the application can send a foreign key of an object back and forth.
