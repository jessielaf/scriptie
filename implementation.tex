\chapter{Implementation of the architecture}

The chosen implementation is modular monolith. Let’s go over the characteristics of modular monolith. As mentioned in \fullref{sec:ModularMonolith} a modular monolith is a domain driven design where the modules can be developed separately. Thus most of the principles can be taken from domain driven design. But because the modules do not know what other modules contain. Thus there should be a kind of api on which the modules talk.

\section{Characteristics}

Domain driven design was coined by Eric Evans in his book Domain driven design \cite{domainDrivenDesign}. Eric Evans himself said that there is no real standard for domain driven design. Let’s first define what a domain is.

\largequote{A domain is a field of study that defines a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering. The word domain is also taken as a synonym of application domain It is also seen as a sphere of knowledge \cite{domainDefinition}}

What is important to note is that each module is linked to a domain but there is a distinct difference between only implementing domain driven design and modular monolith. The main distinct feature is that in a modular monolith the module does know that another module exists but not the contents of this module. This is not the case with domain driven design.

The difference that this makes it that each module should be able to talk with each other and thus there need to be an api over which each module can talk with each other.

\section{Current situation}

This architecture will apply to the application of EFFE. Below is a list of the functionalities of the current application. This is in order to paint a good picture of the current situation.

\begin{enumerate}
    \item Login
    \item Reset password
    \item Shift overview (Roster and table view)
    \item Create shift
    \item Generate schedule: automatically link users with shifts
    \item Hour registration
    \item Shift market: Market of shifts that are not filled completely
    \item Availability form: User can enter his availability. This is together with generate schedule
    \item User CRUD*
    \item Switching shifts
    \item Calling in sick
    \item Client CRUD*
\end{enumerate}

Each functionality belongs to a certain domain. When looking at the functionalities the domains can be defined:

\begin{tabularx}{\linewidth}{|>{}X|>{}X|>{}X|}
    \hline

    Domain
     &
    Functionalities
    &
    Is building block
    \\ \hline

    User
     &
    \begin{compactitem}
        \item Reset password
        \item User CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Shift
     &
    \begin{compactitem}
        \item Shift overview
        \item Create shift
    \end{compactitem}
    &
    No
    \\ \hline

    Skill
     &
    \begin{compactitem}
        \item Skill CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Store
     &
    \begin{compactitem}
        \item Store CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Client
     &
    \begin{compactitem}
        \item Client CRUD*
    \end{compactitem}
    &
    No
    \\ \hline

    Authentication
     &
    \begin{compactitem}
        \item Login
        \item Reset password
    \end{compactitem}
    &
    No
    \\ \hline

    Schedule
     &
    \begin{compactitem}
        \item Generate schedule
    \end{compactitem}
    &
    No
    \\ \hline

    Hour registration
     &
    \begin{compactitem}
        \item Hour registration
    \end{compactitem}
    &
    Yes
    \\ \hline

    Shift market
     &
    \begin{compactitem}
        \item Shift market
    \end{compactitem}
    &
    Yes
    \\ \hline

    Shift change
     &
    \begin{compactitem}
        \item Switching shifts
        \item Calling in sick
    \end{compactitem}
    &
    No
    \\ \hline

    Company
     &
    \begin{compactitem}
        \item Managing company settings
    \end{compactitem}
    &
    No
    \\ \hline
\end{tabularx}

\small{\textcolor{gray}{* CRUD or Create Read Update Delete refers to the actions that can be called on an object}}

As you can see there are only two building blocks. Those are the Hour Registration and the Shift market. But this does not mean that the other domains should not be modules. If every domain is a module it makes it easy for us to change a basic function if an enterprise wants that.

\section{API}
\label{sec:API}

When creating this API the assumption is done that a modern ORM(Object relational mapping) is used.

\largequote{Object-relational-mapping is the idea of being able to write queries, as well as much more complicated ones, using the object-oriented paradigm of your preferred programming language. \cite{ormDefinition}}

This assumption is done because almost every modern framework uses this concept to map objects to a relational database which is what EFFE uses.

Therefore the first attribute defined in our api is the \textbf{model} itself.

Microservices talk with each other via a protocol. The most used protocols are HTTP, TCP or AMQP \cite{microservicesAPI}. What all of these protocols have in common is that they return a serialized version of the response. Most of the time in JSON.

Commonly in web frameworks there is something used like a dataclass or a serializer. This shows how an object will be serialized into a JSON object and send back and forth via http. Thus if the api of a module in the modular monolith can expose such a serializer the application can serialize all the foreign keys the module's model has. But when working with the application of EFFE the company found that each user role may require a other specific serializer. For example: EFFE has three roles: the employment agency employee, the client and the temp worker. If the client and the temp worker want to retrieve the shifts the client also gets the users in that shift while the temp worker only sees the general data of the shift. This is so that temp workers won't have the biased in taking shifts with people they like or vise versa.

Therefore it is important to note that each role should have a specific serializer. So in the API there should be \textbf{base serializer} and the option to change the \textbf{serializer by role}.

\section{Programming language and Web framework}

It is obvious why programming languages will be researched but maybe not why there is a need for a web framework. As mentioned before in this chapter most of the web applications use a web framework.

\largequote{A web framework is a software tool that provides a way to build and run web applications. As a result, you don’t need to write code on your own and waste time looking for possible miscalculations and bugs. \cite{webFrameworkDefinition}}

It is a industry standard to use web frameworks. It simply makes life easier. But which web framework? The comparison will be of the front- and backend frameworks and languages. There will not be a research of the whole framework or language. The only thing that will be researched is the modularity of the framework or language.

\subsection{Backend}
\label{sec:BackendImplementation}

Even though the programming language is important most of the time their modularity comes from the framework that is implemented. According to hackers.io these are the top backend frameworks in 2019 \cite{topFrameworks}

\begin{enumerate}
    \item Express (Node.js)
    \item Django (Python)
    \item Rails (Ruby)
    \item Laravel (PHP)
    \item Spring (Java)
\end{enumerate}

What is interesting to note is that each framework uses a different programming language. There is one that jumps out of the languages that are used. That is Java. This is because Java is the only one that is statically typed. One of the requirements was being as flexible as possible and this is just not possible when working with a statically typed language. Therefore Spring falls off.

There are four frameworks left. These frameworks will be tested with this use case:

There is a shift module. The model has four attributes
\begin{itemize}
    \item Title
    \item Start date
    \item End date
    \item Employees
\end{itemize}

And there is a employee module with the model having these attributes:
\begin{itemize}
    \item Name
    \item Birth date
    \item Email
\end{itemize}

The application will provide an api which do a create, list and retrieve(single object) for both shifts and employees.

Last of all the modules should only talk with each other via the \fullref{sec:API}.

All of these tests are done using Windows 10 on a Dell 13 XPS, usage of the git bash terminal and the usage of MySQL as the primary database.

The assumption is made that the database exists where root is the username and password and the web framework used is the name of the database table.

All the code can be found at \url{https://github.com/jessielaf/modular_monolith}

\begin{itemize}
    \item \fullref{sec:ExpressImpl}
    \item \fullref{sec:DjangoImpl}
    \item \fullref{sec:RailsImpl}
    \item \fullref{sec:LaravelImpl}
    \item \fullref{sec:SpringImpl}
\end{itemize}

Rails and Spring were not successful in the support of creating a modular monolith. Django on the other hand is the only framework that supports this type of architecture out of the box. This is already a lot of reasoning to chose this framework. But what amplifies this choice is the amount of code that is needed to write in order for the test to work was minimal in comparison to other frameworks. Django was also the only framework with build-in database migration generation. This allows the user to create migrations based on the model. This is very important because it eliminates human error when creating migrations by hand like all the other options.

\subsection{Frontend}

Frontend is a very fast moving section of software engineering. On october 8th 2010 \cite{angularJs} the first big frontend framework was published called AngularJs. This framework has been maintained by google and received a lot of traction. Three years later at Js ConfUS Jordan Walke of Facebook gave a introduction to React \cite{reactJs}. This changed the frontend world. Mainly because react was not a framework but a library. Which means that you are able to include it in your existing project where with angular you solely have angular application. In February 2014 the last big javascript framework would be released called Vue \cite{vueJs}. Vue is often seen as the perfect blend between React and Angular. This is partly because Vue can be used as a library and a framework.

These three frameworks / libraries where chosen because they are the most used and the most loved by the javascript community \cite{allFrontendFrameworks}.

First off there is a need to define what should be in the api of each module in the frameworks. There is only one actual layer the modules should export and that is the service. The service of a model as explained in \fullref{sec:BackendImplementation}. They should export all the CRUD functionalities.

The scope of the test is that the frontend application should use our backend site created in \fullref{sec:BackendImplementation}. So the application should be able to do:

\begin{itemize}
    \item Create a employee
    \item List the employees
    \item Detail employee view
    \item List shifts
    \item Add shifts
    \item Detail shift view
\end{itemize}

All the code can be found at \url{https://github.com/jessielaf/modular_monolith}

\begin{itemize}
    \item \fullref{sec:VueImpl}
    \item \fullref{sec:ReactImpl}
    \item \fullref{sec:AngularImpl}
\end{itemize}

From the implementations it is obvious that angular is harder to implement than vue or react. This is a combination of typescript and dependency injection which angular uses. Vue and react on the other hand are really similar. But there are a few differences that makes vue easier to use than react. The first one is the two way binding of vue \cite{vueTwoWay}. React does not have this feature. What this means is that you have to write your own handler for every different input. Another difference is that with Vue the router is included. Thus the vue router is supported by the official team. React does not have a router build in. Thus the choice goes to Vue.
